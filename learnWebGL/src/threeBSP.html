<!--
 * @Author: your name
 * @Date: 2019-10-30 09:16:53
 * @LastEditTime: 2019-10-31 17:15:07
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /node/learnWebGL/src/threeBSP.html
 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script type="text/javascript" src="./lib/three.js"></script>
    <script type="text/javascript" src="./lib/ThreeCSG.js"></script>
    <script src="./lib/OrbitControls1.js"></script>
    <script src="./lib/earcut.js"></script>
    <title>Document</title>
    <style>
        #conianer {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <div id="conianer"></div>
</body>
<script type="x-shader/x-vertex" id="vertexShader">

    varying vec3 vWorldPosition;

    void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

</script>


<script id="vertexShader1" type="x-shader/x-vertex">
    void main() {
        gl_Position = vec4( position, 1.0 );
    }
</script>
<script id="fragmentShader1" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision mediump float;
    #endif
    
    uniform vec2 u_resolution;
    uniform vec2 u_mouse;
    uniform float u_time;
    
    vec3 colorA = vec3(0.149,0.141,0.912);
    vec3 colorB = vec3(1.000,0.833,0.224);
    void main() {
        vec3 color = vec3(0.0);

        float pct = abs(sin(u_time));

    // Mix uses pct (a value from 0-1) to
    // mix the two colors
        color = mix(colorA, colorB, pct);

        gl_FragColor = vec4(color,1.0);
    }
    
</script>
<script type="x-shader/x-fragment" id="fragmentShader">

    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform float offset;
    uniform float exponent;

    varying vec3 vWorldPosition;

    void main() {

        float h = normalize( vWorldPosition + offset ).y;
        gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );

    }

</script>
<script>
    var scene;
    function initScene() {
        scene = new THREE.Scene();
    }

    var container;
    function initContainer() {
        container = document.getElementById('conianer');
    }

    var renderer;
    function initRender() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        //renderer.setClearColor(new THREE.Color(0xffffff)); //设置背景颜色
        renderer.setSize(container.offsetWidth, container.offsetHeight);
        container.appendChild(renderer.domElement);
    }

    var camera;
    function initCamera() {
        // camera = new THREE.PerspectiveCamera(35, container.offsetWidth / container.offsetHeight, 1, 1000);
        // camera.position.set(5, 5, 15);
        // camera.lookAt(new THREE.Vector3(0, 30, 0));
        // camera.position.z = 1;

        camera = new THREE.PerspectiveCamera(40, container.offsetWidth / container.offsetHeight, 1, 10000);
        camera.position.set(700, 200, - 500);
    }


    var light;

    function initLight() {
        //环境光
        scene.add(new THREE.AmbientLight(0x404040));
        //直射光

        light = new THREE.DirectionalLight(0xaabbff, 0.3);
        light.position.x = 300;
        light.position.y = 250;
        light.position.z = - 500;
        scene.add(light);
    }

    //用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放
    var controls;

    function initControls() {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true;
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        //controls.dampingFactor = 0.25;
        //是否可以缩放
        controls.enableZoom = true;
        //是否自动旋转
        controls.autoRotate = false;
        //设置相机距离原点的最远距离
        controls.minDistance = 20;
        //设置相机距离原点的最远距离
        controls.maxDistance = 10000;
        //是否开启右键拖拽
        controls.enablePan = true;
    }
    function render() {
        uniforms["u_time"].value = Date.now() * 0.0000001 * 0.00001;
        //mesh.geometry.attributes.u_time.needsUpdate = true;
        renderer.render(scene, camera);
    }

    function animate() {
        //更新控制器
        controls.update();
        render();
        requestAnimationFrame(animate);
    }
    /**
     * @description: 添加模型的交互补
     * @param {type}  intersect////union////subtract
     * @return: 
     */
    var uniforms
    function initModel() {

        //辅助工具
        var helper = new THREE.AxesHelper(500);
        scene.add(helper);

        var cube_geometry = new THREE.CubeGeometry(30, 30, 30);
        var cube_mesh = new THREE.Mesh(cube_geometry);
        cube_mesh.position.x = -7;
        var cube_bsp = new ThreeBSP(cube_mesh);
        var sphere_geometry = new THREE.SphereGeometry(18, 32, 32);
        var sphere_mesh = new THREE.Mesh(sphere_geometry);
        sphere_mesh.position.x = -7;
        var sphere_bsp = new ThreeBSP(sphere_mesh);

        var subtract_bsp = cube_bsp.subtract(sphere_bsp);
        var MeshLambertMaterial = new THREE.MeshLambertMaterial({
            shading: THREE.SmoothShading,
            map: new THREE.TextureLoader().load('texture.png')
        })

        uniforms = {
            u_time: { type: "f", value: 1 },
            u_resolution: { type: "v2", value: new THREE.Vector2() }
        };
        var shaderMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: document.getElementById('vertexShader1').textContent,
            fragmentShader: document.getElementById('fragmentShader1').textContent
        });
        var result = subtract_bsp.toMesh(MeshLambertMaterial);

        result.geometry.computeVertexNormals();
        scene.add(result);
    }

    /**
     * @description: 添加天空shader
     * @param {type} 
     * @return: 
     */
    function addSky() {
        console.log(new Date().getSeconds())
        var vertexShader = document.getElementById('vertexShader').textContent;
        var fragmentShader = document.getElementById('fragmentShader').textContent;
        var uniforms = {
            topColor: { value: new THREE.Color(0x0077ff) },
            bottomColor: { value: new THREE.Color(0xffffff) },
            offset: { value: 400 },
            exponent: { value: 0.6 }
        };
        uniforms.topColor.value.copy(light.color);
        var skyGeo = new THREE.SphereBufferGeometry(4000, 32, 15);
        var skyMat = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.BackSide
        });

        var sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);
    }
    function addShaderMaterial() {
        // var geometry = new THREE.PlaneBufferGeometry(1, 1, 2);
        // //sphere_mesh.position.x = 10;
        // uniforms = {
        //     u_time: { type: "f", value: 1 },
        //     u_resolution: { type: "v2", value: new THREE.Vector2() }
        // };
        // var shaderMaterial = new THREE.ShaderMaterial({
        //     uniforms: uniforms,
        //     vertexShader: document.getElementById('vertexShader1').textContent,
        //     fragmentShader: document.getElementById('fragmentShader1').textContent
        // });
        // var mesh = new THREE.Mesh(geometry, shaderMaterial);
        var points = [
            [10, 0, 2],
            [13, 0, 4],
            [0, 0, 10],
            [5, 0, 10],
        ]
        var geometry = getGeometry(points, 5);
        var MeshLambertMaterial = new THREE.MeshLambertMaterial({ color: 0xaabbff, side: THREE.DoubleSide });
        var mesh = new THREE.Mesh(geometry, MeshLambertMaterial);
        scene.add(mesh);
    }

    function getGeometry(points, height) {
        var topPoints = [];
        for (var i = 0; i < points.length; i++) {
            var vertice = points[i];
            topPoints.push([vertice[0], vertice[1] + height, vertice[2]]);
        }
        var totalPoints = points.concat(topPoints);
        var vertices = [];           //所有的顶点
        for (var i = 0; i < totalPoints.length; i++) {
            vertices.push(new THREE.Vector3(totalPoints[i][0], totalPoints[i][1], totalPoints[i][2]))
        }
        var length = points.length;
        var faces = [];
        for (var j = 0; j < length; j++) {                      //侧面生成三角形
            if (j != length - 1) {
                faces.push(new THREE.Face3(j, j + 1, length + j + 1));
                faces.push(new THREE.Face3(length + j + 1, length + j, j));
            } else {
                faces.push(new THREE.Face3(j, 0, length));
                faces.push(new THREE.Face3(length, length + j, j));
            }
        }
        var data = [];
        for (var i = 0; i < length; i++) {
            data.push(points[i][0], points[i][2]);
        }
        var triangles = earcut(data);
        if (triangles && triangles.length != 0) {
            for (var i = 0; i < triangles.length; i++) {
                var tlength = triangles.length;
                if (i % 3 == 0 && i < tlength - 2) {
                    faces.push(new THREE.Face3(triangles[i], triangles[i + 1], triangles[i + 2]));                            //底部的三角面
                    faces.push(new THREE.Face3(triangles[i] + length, triangles[i + 1] + length, triangles[i + 2] + length));        //顶部的三角面
                }
            }
        }
        var geometry = new THREE.Geometry();
        geometry.vertices = vertices;
        geometry.faces = faces;
        geometry.computeFaceNormals();      //自动计算法向量
        return geometry;
    }
    //窗口变动触发的函数
    function onWindowResize() {

        camera.aspect = container.innerWidth / container.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.innerWidth, container.innerHeight);

    }
    function draw() {

        initContainer();
        initRender();
        initScene();
        initCamera();
        initLight();
        initModel();
        addSky();
        addShaderMaterial();
        initControls();
        animate();
        // window.onresize = onWindowResize;
    }

    draw();
</script>

</html>